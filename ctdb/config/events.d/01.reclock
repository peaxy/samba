#!/bin/sh
# script to check accessibility to the reclock file on a node

[ -n "$CTDB_BASE" ] || \
    export CTDB_BASE=$(cd -P $(dirname "$0") ; dirname "$PWD")

. $CTDB_BASE/functions
loadconfig

case "$1" in
    init)
	ctdb_counter_init

	if [ -n "$CTDB_RECOVERY_LOCK" ] ; then
	    d=$(dirname "$CTDB_RECOVERY_LOCK")
	    mkdir -vp "$d"
	fi
	;;

    monitor)
	# Early exit if not using a reclock file
	[ -n "$CTDB_RECOVERY_LOCK" ] || exit 0

	# Try to stat the reclock file as a background process so that
	# we don't block in case the cluster filesystem is unavailable
	(
	    # This script is called once every MonitorInterval cycle,
	    # so always stat the reclock file.
	    CMD_OUT=`stat $CTDB_RECOVERY_LOCK`
	    RETURN_CODE="$?"
	    evt_logger "01.reclock stat return code $RETURN_CODE"
	    evt_logger "01.reclock stat output $CMD_OUT"
	    if [ "$RETURN_CODE" == 0 ]; then
		# We could stat the file, reset the counter
		ctdb_counter_init
	    fi
	) >/dev/null 2>&1 &

	ctdb_counter_incr
	if ! ctdb_check_counter "quiet" -ge 210 ; then
	    echo "Reclock file \"$CTDB_RECOVERY_LOCK\" can not be accessed. Shutting down."
	    # df
	    # sleep 1
	    # If NS resync is stuck, "df" above will get stuck. We won't be able to shutdown CTDB.
	    sleep 5
	    ctdb shutdown
	fi

	ctdb_check_counter "error" -gt 90
	;;

    *)
	ctdb_standard_event_handler "$@"
	;;
esac

exit 0
